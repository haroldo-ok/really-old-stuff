<!DOCTYPE html><html><head>	<style TYPE="text/css">		dl		{			display: inline-block;		}	</style>	<script src="jquery-1.8.1.js" type="text/javascript"></script>	<script src="base64.js" type="text/javascript"></script></head><body>		<div>		<dl>			<dt>Original video</dt>			<dd>				<video id="source-video" width="560" height="340">			<!--		<source type="video/webm" src="Metal_Dust_Trailer_small.webm"></source> -->					<source type="video/webm" src="Road-Blaster.webm"></source>			<!--		<source type="video/webm" src="Star Rider.webm"></source> -->				</video>			</dd>		</dl>		<dl>			<dd><canvas id="thumbnail-canvas" width="64" height="48"></canvas></dd>			<dd><canvas id="decode-canvas" width="64" height="48"></canvas></dd>		</dl>		<dl>			<dt>Colors per line</dt>			<dd><canvas id="preview-canvas" width="256" height="192"></canvas></dd>			<dt>Colors per frame</dt>			<dd><canvas id="preview-canvas2" width="256" height="192"></canvas></dd>		</dl>		<input type="button" id="botao-iniciar" value="Iniciar" />	</div>		<div>		<p>Compressed</p>		Hex	<textarea id="hexdata"></textarea>		Base64 <textarea id="base64"></textarea>	</div>	<div>		<p>Uncompressed</p>		Hex	<textarea id="hexdatau"></textarea>		Base64 <textarea id="base64u"></textarea>	</div>			<script>		var sourceVideo = document.getElementById('source-video');		var thumbnailCanvas = document.getElementById('thumbnail-canvas');		var previewCanvas = document.getElementById('preview-canvas');		var decodeCanvas = document.getElementById('decode-canvas');		var previewCanvas2 = document.getElementById('preview-canvas2');		var hexField = document.getElementById('hexdata');		var base64Field = document.getElementById('base64');		var hexUField = document.getElementById('hexdatau');		var base64UField = document.getElementById('base64u');				$('#botao-iniciar').click(function(){			sourceVideo.width = sourceVideo.videoWidth;			sourceVideo.height = sourceVideo.videoHeight;						ctx = thumbnailCanvas.getContext('2d');			ctx2 = previewCanvas.getContext('2d');			ctx3 = previewCanvas2.getContext('2d');						function computeFrame() {				ctx.drawImage(sourceVideo, 0, 0, thumbnailCanvas.width, thumbnailCanvas.height);				var frameData = reduceColors(ctx);										ctx2.mozImageSmoothingEnabled=false;				ctx2.drawImage(thumbnailCanvas, 0, 0, previewCanvas.width, previewCanvas.height);								return frameData;			}						function reduceColors(ctx) {				var frame = ctx.getImageData(0, 0, thumbnailCanvas.width, thumbnailCanvas.height);								var indexes = [];				var palettes = [];				for (var i = 0; i < thumbnailCanvas.height; i++) {					palettes.push([						{r: 0, g: 0, b: 0, ct: 0},						{r: 0, g: 0, b: 0, ct: 0},						{r: 0, g: 0, b: 0, ct: 0},						{r: 0, g: 0, b: 0, ct: 0}					]);				}								var l = frame.data.length / 4;				for (var i = 0; i < l; i++) {															var r = frame.data[i * 4 + 0];					var g = frame.data[i * 4 + 1];					var b = frame.data[i * 4 + 2];					var y = Math.floor(i / thumbnailCanvas.width);					//var shade = (r + g + b) / 3;					var shade = Math.min(Math.max(Math.round(0.30 * r + 0.59 * g + 0.11 * b), 0), 255); // Luma value					var index = shade >> 6;					var color = index << 6;					indexes.push(index);					var palette = palettes[y];					palette[index].r += r;					palette[index].g += g;					palette[index].b += b;					palette[index].ct++;				}								// Calculates the per-frame palette				var framePalette = palettes.reduce(function(tot, pal){					for (var i = 0; i < tot.length; i++) {						tot[i].r += pal[i].r;						tot[i].g += pal[i].g;						tot[i].b += pal[i].b;						tot[i].ct += pal[i].ct;					}					return tot;				}, [					{r: 0, g: 0, b: 0, ct: 0},					{r: 0, g: 0, b: 0, ct: 0},					{r: 0, g: 0, b: 0, ct: 0},					{r: 0, g: 0, b: 0, ct: 0}				]).map(function(entry){					entry.r /= entry.ct;					entry.g /= entry.ct;					entry.b /= entry.ct;					entry.r &= 0xC0;					entry.g &= 0xC0;					entry.b &= 0xC0;										return entry;				});				// Calculates the per-line palette				palettes.forEach(function(pal){					pal.forEach(function(entry){						entry.r /= entry.ct;						entry.g /= entry.ct;						entry.b /= entry.ct;						entry.r &= 0xC0;						entry.g &= 0xC0;						entry.b &= 0xC0;					});					window.pal = pal;				});								for (var i = 0; i < l; i++) {					var y = Math.floor(i / thumbnailCanvas.width);					var palette = palettes[y];					var pal = palette[indexes[i]];					frame.data[i * 4 + 0] = pal.r;					frame.data[i * 4 + 1] = pal.g;					frame.data[i * 4 + 2] = pal.b;						  				}				ctx.putImageData(frame, 0, 0);												return {					indexes: indexes,					palettes: palettes,					framePalette: framePalette				};			}						function drawFrame(canvas, frameData) {				var ctx = canvas.getContext('2d');								var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);				var pixels = frameData.indexes;				var colors = frameData.palettes;								for (var pixNum = 0; pixNum < pixels.length; pixNum++) {					var pixVal = pixels[pixNum];					frame.data[pixNum * 4 + 0] = pixVal << 6;						frame.data[pixNum * 4 + 1] = pixVal << 6;						frame.data[pixNum * 4 + 2] = pixVal << 6;						frame.data[pixNum * 4 + 3] = 256;				}				ctx.putImageData(frame, 0, 0);			}						function drawSinglePaletteFrame(canvas, frameData) {				var ctx = canvas.getContext('2d');								var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);				var pixels = frameData.indexes;				var colors = frameData.palettes;				var frameColors = frameData.framePalette;								for (var pixNum = 0; pixNum < pixels.length; pixNum++) {					var pixVal = pixels[pixNum];					var pal = frameColors[pixVal];					frame.data[pixNum * 4 + 0] = pal.r;					frame.data[pixNum * 4 + 1] = pal.g;					frame.data[pixNum * 4 + 2] = pal.b;					frame.data[pixNum * 4 + 3] = 256;				}				ctx.putImageData(frame, 0, 0);			}			function decodeTiles(tiles) {				var ow = decodeCanvas.width;				var oh = decodeCanvas.height;				var w = ow >> 1;				var h = oh >> 1;				var tileIdx = 0;				var pixels = [];				for (var y = 0; y < h; y++) {					for (var x = 0; x < w; x++) {						var ox = x << 1;						var oy = y << 1;						var tile = tiles[tileIdx];						var pxTL = tile >> 0 & 0x03;						var pxTR = tile >> 2 & 0x03;						var pxBL = tile >> 4 & 0x03;						var pxBR = tile >> 6 & 0x03;												pixels[oy * ow + ox] = pxTL;						pixels[oy * ow + (ox + 1)] = pxTR;						pixels[(oy + 1) * ow + ox] = pxBL;						pixels[(oy + 1) * ow + (ox + 1)] = pxBR;																		tileIdx++;					}				}				return pixels;			}						function encodeTiles(pixels) {				var tiles = [];								var ow = thumbnailCanvas.width;				var oh = thumbnailCanvas.height;				var w = ow >> 1;				var h = oh >> 1;								for (var y = 0; y < h; y++) {					for (var x = 0; x < w; x++) {						var ox = x << 1;						var oy = y << 1;												var pxTL = pixels[oy * ow + ox];						var pxTR = pixels[oy * ow + (ox + 1)];						var pxBL = pixels[(oy + 1) * ow + ox];						var pxBR = pixels[(oy + 1) * ow + (ox + 1)];												var tile = ((pxBR << 2 | pxBL) << 2 | pxTR) << 2 | pxTL;												tiles.push(tile);					}				}								return tiles;			}									var RLE_MAX_BLOCK_SIZE = 64;			var RLE_IMMEDIATE_MASK = 0x00;			var RLE_REPEAT_MASK = 0x40;			var RLE_FRAME_COPY_MASK = 0x80;			var RLE_CMD_MASK = 0xC0;			var RLE_LEN_MASK = 0x3F;										function encodeRLEStructure(tiles) {				var rle = [];				var block = [];				var repeated = false;				tiles.forEach(function(tile){					if (!block.length) {						block.push(tile);					} else if (block.length == 1) {						repeated = (tile == block[0]);						block.push(tile);					} else if (repeated) {						if (tile != block[block.length - 1]) {							if (block.length < 2) {								block.push(tile);								repeated = false;							} else {								rle.push({ t: 'repeat', b: block });								block = [tile];							}						} else {							block.push(tile);							if (block.length == RLE_MAX_BLOCK_SIZE) {								rle.push({ t: 'repeat', b: block });								block = [];							} else if (block.length > RLE_MAX_BLOCK_SIZE) {								throw new Error("Invalid block length: " + block);							}						}					} else {						if (tile == block[block.length - 1]) {							block.pop();							rle.push({ t: 'immediate', b: block });							block = [tile, tile];							repeated = true;						} else {							block.push(tile);							if (block.length == RLE_MAX_BLOCK_SIZE) {								rle.push({ t: 'immediate', b: block });								block = [];							} else if (block.length > RLE_MAX_BLOCK_SIZE) {								throw new Error("Invalid block length: " + block);							}						}					}				});								if (block.length) {					rle.push({ t: repeated ? 'repeat' : 'immediate', b: block });				}								return rle;			}										function encodeFrameDeltaStructure(tiles, prevTiles) {				var rle = [];				var block = [];				var repeated = false;				tiles.forEach(function(tile, i){					prevTile = prevTiles[i];									if (!block.length) {						block.push(tile);						repeated = (tile == prevTile);					} else if (block.length == 1) {						repeated &= (tile == prevTile);						block.push(tile);					} else if (repeated) {						if (tile != prevTile) {							if (block.length < 2) {								block.push(tile);								repeated = false;							} else {								rle.push({ t: 'prevFrame', b: block });								block = [tile];								repeated = false;							}						} else {							block.push(tile);							if (block.length == RLE_MAX_BLOCK_SIZE) {								rle.push({ t: 'prevFrame', b: block });								block = [];							} else if (block.length > RLE_MAX_BLOCK_SIZE) {								throw new Error("Invalid block length: " + block);							}						}					} else {						if (tile == prevTile) {							rle.push({ t: 'immediate', b: block });							block = [tile];							repeated = true;						} else {							block.push(tile);							if (block.length == RLE_MAX_BLOCK_SIZE) {								rle.push({ t: 'immediate', b: block });								block = [];							} else if (block.length > RLE_MAX_BLOCK_SIZE) {								throw new Error("Invalid block length: " + block);							}						}					}				});								if (block.length) {					rle.push({ t: (repeated && block.length > 1) ? 'prevFrame' : 'immediate', b: block });				}								return rle;			}				function encodeFrameDeltaRLEStructure(tiles, prevTiles) {				return encodeFrameDeltaStructure(tiles, prevTiles).reduce(function(ret, cmd){					if (cmd.t == 'immediate') {						ret = ret.concat(encodeRLEStructure(cmd.b));					} else {						ret.push(cmd);					}										return ret;				}, []);			}						function encodeStructureToBytes(structure) {				return structure.reduce(function(a, cmd){					if (cmd.t == 'repeat') {						a.push(RLE_REPEAT_MASK | (cmd.b.length - 1)); // Command + length						a.push(cmd.b[0]); // What to repeat					} else if (cmd.t == 'prevFrame') {						a.push(RLE_FRAME_COPY_MASK | (cmd.b.length - 1)); // Command + length					} else {											a.push(RLE_IMMEDIATE_MASK | (cmd.b.length - 1)); // Command + length						a = a.concat(cmd.b); // Literal data					}										return a;				}, []);			}						function decodeBytes(encoded, prevTiles) {				var decoded = [];				var idx = 0;				while (idx < encoded.length) {					var cmd = encoded[idx++];					var len = (cmd & RLE_LEN_MASK) + 1;					var cmd = cmd & RLE_CMD_MASK;										switch (cmd) {						case RLE_IMMEDIATE_MASK:							// Copy 'len' bytes, as they are.							for (var i = 0; i < len; i++) {								decoded.push(encoded[idx++]);							}							break;						case RLE_REPEAT_MASK:							// Repeat 'val' bytes, 'len' times.							var val = encoded[idx++];							for (var i = 0; i < len; i++) {								decoded.push(val);							}							break;						case RLE_FRAME_COPY_MASK:							// Copy 'len' bytes from the corresponding positions on the previous frame.							for (var i = 0; i < len; i++) {								decoded.push(prevTiles[decoded.length]);							}							break;						default:							throw new Error("Unknowm command: " + cmd + ' at ' + idx);					}				}				return decoded;			}						function compressTiles(tiles, prevTiles) {				var rle = encodeFrameDeltaRLEStructure(tiles, prevTiles);								var encoded = encodeStructureToBytes(rle);				return encoded;			}						function encodePaletteToBytes(frameData) {				return frameData.palettes.reduce(function(a, pal){					return a.concat(pal.map(function(entry){						return entry.r >> 6 | entry.g >> 4 | entry.b >> 2;					}));				}, []);			}						function encodeFramePaletteToBytes(frameData) {				return frameData.framePalette.map(function(entry){					return entry.r >> 6 | entry.g >> 4 | entry.b >> 2;				});			}						// Converts byte to hex, inserting line breaks every 16 chars			function encodeHex(data) {				return data.reduce(function(s, n, i){					var hex = (n > 15 ? '' : '0') + n.toString(16);					var spc = i && !(i & 0xF) ? '\n' : ' ';					return s + spc + hex;				}, '').trim();			}			// Base 64 encoding taken from http://stackoverflow.com/questions/5366727/convert-array-of-byte-values-to-base64-encoded-string-and-break-long-lines-java			function encodeBase64(data) {				var str = "";				for (var i = 0; i < data.length; i++) {					str += String.fromCharCode(data[i]);				}				return btoa(str).split(/(.{75})/).join("\n").replace(/\n+/g, "\n").trim();			}			var fpsRate = 10;			var frameIncrement = 1 / fpsRate;						var prevTiles = [];			for (var i = 0, l = thumbnailCanvas.width * thumbnailCanvas.height; i < l; i++) {				prevTiles.push(0);			}						var prevPalette = [];			for (var i = 0, l = thumbnailCanvas.height * 4; i < l; i++) {				prevPalette.push(0);			}						var fullCompressedData = [];			var fullUncompressedData = [];						var totalSize = 0;			var totalCompressed = 0;			var currentTime = 0;//			var duration = sourceVideo.duration; // Full//			var duration = 10; // 10 seconds			var duration = 4 * 60 + 42; // 4 min, 42 secs			sourceVideo.onseeked = function() {				currentTime += frameIncrement;				if (currentTime >= duration) {					console.log({totalUncompressed: totalSize, totalCompressed: totalCompressed});										hexField.value = encodeHex(fullCompressedData);					base64Field.value = encodeBase64(fullCompressedData);										hexUField.value = encodeHex(fullUncompressedData);					base64UField.value = encodeBase64(fullUncompressedData);										alert('Okay, it\'s done.');										return;				}								var frameData = computeFrame();								var tiles = encodeTiles(frameData.indexes);				var encoded = compressTiles(tiles, prevTiles);				var decoded = decodeBytes(encoded, prevTiles);								var palette = encodePaletteToBytes(frameData);				var encodedPalette = compressTiles(palette, prevPalette);				var framePalette = encodeFramePaletteToBytes(frameData);								console.log({					time: currentTime, 					uncompressed: tiles.length, 					compressed: encoded.length,					uncompressedPal: palette.length,					compressedPal: encodedPalette.length				});				totalSize += tiles.length + palette.length;				totalCompressed += encoded.length + encodedPalette.length;								for (i = 0; i < tiles.length; i++) {					if (tiles[i] != decoded[i]) {						throw new Error('Encoding error at idx = ' + i + ': ' + tiles[i] +' != ' + decoded[i]);					}				}				frameData.indexes = decodeTiles(tiles);//				drawFrame(decodeCanvas, frameData);				drawSinglePaletteFrame(decodeCanvas, frameData);								ctx3.mozImageSmoothingEnabled=false;				ctx3.drawImage(decodeCanvas, 0, 0, previewCanvas2.width, previewCanvas2.height);								/*				fullCompressedData = fullCompressedData.concat(encoded).concat(encodedPalette);				fullUncompressedData = fullUncompressedData.concat(tiles).concat(palette);				*/				fullCompressedData = fullCompressedData.concat(encoded).concat(framePalette);				fullUncompressedData = fullUncompressedData.concat(tiles).concat(framePalette);								// Requests next frame				prevTiles = tiles;				prevPalette = palette;				sourceVideo.currentTime = currentTime;			};			// Starts processing the frames			sourceVideo.currentTime = 0;		});	</script></body></html>